<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Apr 15 12:42:17 GMT+10:00 2002 -->
<TITLE>
DoctypeChanger version 1.1, April 15 2002: Overview
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="net/socialchange/doctype/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<CENTER>
<H2>
DoctypeChanger version 1.1, April 15 2002</H2>
</CENTER>

		DoctypeChanger is a Java class that lets you add, modify or remove a DOCTYPE
		declaration from a byte stream as it is fed into an XML parser.
<P>
<B>See: </B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Packages</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="net/socialchange/doctype/package-summary.html">net.socialchange.doctype</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<p>
		DoctypeChanger is a Java class that lets you add, modify or remove a DOCTYPE
		declaration from a byte stream as it is fed into an XML parser.
		</p>
		<div align="left">
			<ul>
				<li><a href="#doc.Credits">Credits</a></li>
				<li><a href="#doc.Intro">Introduction</a></li>
				<li><a href="#doc.Function">What can it do?</a></li>
				<li><a href="#doc.Use">How to use it</a></li>
				<ul>
					<li><a href="#doc.Examples">Examples</a></li>
					<li>Remove any existing doctype declaration</li>
					<li>Replace any old doctype declaration with ours</li>
					<li>Replace only the system id</li>
					<li>Replace the system id if the public id matches something</li>
					<li><a href="#doc.Demo">Demo program</a></li>
				</ul>
				<li><a href="#doc.Charset">Encoding issues</a></li>
				<li><a href="#doc.CharVSByte"><code>FilterInputStream</code> vs <code>FilterReader</code></a></li>
				<li><a href="#doc.Other">Other useful stuff</a></li>
				<ul>
					<li><a href="#doc.Validating">Validating against a local DTD</a></li>
					<li><a href="#doc.Catalogs">XML Catalogs</a></li>
					<ul>
						<li>Where to get catalog code</li>
					</ul>
				</ul>
				<li><a href="#doc.Feedback">Feedback</a></li>
				<li><a href="#doc.ChangeLog">ChangeLog</a></li>
				<li><a href="#doc.License">License, copyright, legal stuff</a></li>
			</ul>
		</div>


		  <h2><a name="doc.Credits">Credits</a></h2>
		<p>
		DoctypeChanger is based on code by a nice fellow called Simon St.Laurent, who
		pointed me to it when I asked on the XML-DEV mailing list. The original
		code can be downloaded <a
			href="http://www.simonstl.com/projects/doctypes/">here</a>. Thanks
		Simon!
		</p>

		<h2><a name="doc.Intro">Introduction</a></h2>

		<p>A DOCTYPE declaration, in case you were wondering, is the line at
		the top of some XML/SGML docs. For example:</p>
		<pre>
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
		</pre>
		<p>
		Most of your life you can happily ignore these things. Then one day
		you'll want to validate your XML, perhaps against a local DTD. "No
		problem, I'll just tell my parser that my local DTD is <em>here</em>
		and I <em>always</em> want to validate what I'm getting." Aha.. at this
		point you'll find that, due to some fundamental law, all XML parsers
		will stubbornly:
		</p>
		<ul>
			<li>refuse to validate if a DOCTYPE declaration isn't present</li>
			<li>try to resolve your DOCTYPE declaration's SYSTEM id, no matter
			what it is.</li>
		</ul>

		<p>
		Now this isn't very useful. Say I'm getting XML from a remote source
		over which I have no control. If the incoming XML doesn't have a
		DOCTYPE, I simply can't validate. If it does have a DOCTYPE:</p>
		<ul>
			<li>It might be invalid (simply wrong, or relative to someone's
			filesystem</li>
			<li>It might be inaccessible (behind a firewall, on a server that's
			down, or we're offline).</li>
			<li>The performance hit of fetching a DTD on every request might be
			too high</li>
		</ul>

		<p>
		So until XML parsers change, it seems the only workaround is to
		manipulate the incoming XML stream, and manipulate the DOCTYPE
		declaration before the parser sees it. That is what DoctypeChanger does.
		</p>

		<p>
		<em>Update (18/11/01):</em> it seems the XML gods have heard our cries,
		and there is an enhanced SAX <code>EntityResolver</code> in the works,
		which will let one set a DTD even if no DOCTYPE declaration is present.
		The relevant interface is <a
			href="http://sax.sourceforge.net/apidoc/org/xml/sax/ext/EntityResolver2.html">org.xml.sax.ext.EntityResolver2</a>

		</p>

		<h2><a name="doc.Function">What can it do?</a></h2>
		<p>
		With DoctypeChanger, you can do just about any manipulation of a DOCTYPE
		declaration. Add it, remove it, replace bits of it.. anything :). You
		are given access to the old DOCTYPE declaration, so it's possible to
		express conditional replacement, like "if the old public id is
		<b>-//OASIS//DTD DocBook XML V4.1.2//EN</b>, then make the system id
		<b>/usr/share/sgml/docbook/xml-dtd-4.1.2/docbookx.dtd</b>".
		</p>

		<h2><a name="doc.Use">How to use it</a></h2>

		<p>
		It works like this: you implement a <em>Generator</em> class which
		determines the new DOCTYPE declaration. Your Generator is passed the
		old DOCTYPE declaration, so your new generated DOCTYPE declaration can
		somehow depend on the old one. Typically this is done with an anonymous
		inner class, like Swing event handlers.
		</p>
		<h3><a name="doc.Examples">Examples</a></h3>
		<h4>Remove any existing doctype declaration</h4>
		<p>This is done by always returning a <code>null</code> <code>Doctype</code> object.
		</p>
		<pre>
InputStream in = ...   // get your XML InputStream
DoctypeChangerStream changer = new DoctypeChangerStream(in);
changer.setGenerator(<font color="blue">
    new DoctypeGenerator() {
    public Doctype generate(Doctype old) {
        return null;
        }
    } </font>
);
// .. and pass it on to the parser.
</pre>

		<h4>Replace any old doctype declaration with ours</h4>
		<p>Here we ignore the old doctype declaration, and just return a new
		one.</p>
		<pre>
InputStream in = ...   // get your XML InputStream
DOCTYPEChangerStream changer = new DOCTYPEChangerStream(in);
changer.setGenerator( <font color="blue">
    new DoctypeGenerator() {
        public Doctype generate(Doctype old) {
            return new DoctypeImpl("rootElement", "pubId", "sysId", "internalSubset");
        }
    } </font>
);
// .. and pass it on to the parser.
</pre>


		<h4>Replace only the system id</h4>
		<p>Done by "passing through" all parts of the old doctype declaration,
		except the system id, which we replace.</p>
		<pre>
InputStream in = ...   // get your XML InputStream
DOCTYPEChangerStream changer = new DOCTYPEChangerStream(in);
changer.setGenerator( <font color="blue">
    new DoctypeGenerator() {
        public Doctype generate(Doctype old) {
            return new DoctypeImpl(
                old.getRootElement(),
                old.getPublicId(),
                "/home/jeff/dtds/mydtd.dtd",
                old.getInternalSubset()
            );
        }
    } </font>
);
// .. and pass it on to the parser.
</pre>

		<h4>Replace the system id if the public id matches something</h4>
		<p>
		This is our example, "if the old public id is
		<b>-//OASIS//DTD DocBook XML V4.1.2//EN</b>, then make the system id
		<b>/usr/share/sgml/docbook/xml-dtd-4.1.2/docbookx.dtd</b>. Otherwise,
		strip out the doctype declaration.".
		</p>
		<pre>
InputStream in = ...   // get your XML InputStream
DOCTYPEChangerStream changer = new DOCTYPEChangerStream(in);
changer.setGenerator( <font color="blue">
    new DoctypeGenerator() {
        public Doctype generate(Doctype old) {
            if (old.getPublicId().equals(
            "-//OASIS//DTD DocBook XML V4.1//EN")) {
                return new DoctypeImpl(
                    old.getRootElement(),
                    old.getPublicId(),
                    "/usr/share/sgml/docbook/xml-dtd-4.1.2/docbookx.dtd",
                    old.getInternalSubset()
                );
            } else return null;
        }
    } </font>
    );
// .. and pass it on to the parser.
</pre>

		<p>I hope you get the picture :)</p>

		<h3><a name="doc.Demo">Demo program</a></h3>
		<p>To get you going, here is a bit of standard JAXP code which
		demonstrates the typical DoctypeChanger usage:</p>
		<pre>
import net.socialchange.doctype.DoctypeChangerStream;
import net.socialchange.doctype.DoctypeGenerator;
import net.socialchange.doctype.Doctype;
import net.socialchange.doctype.DoctypeImpl;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.xml.sax.SAXException;

import java.io.InputStream;
import java.io.IOException;
import java.io.FileInputStream;
import java.net.URL;

public class Parse {
	public static InputStream getXMLStream(String uri) throws IOException {
		InputStream fileIn = new URL(uri).openStream();
		DoctypeChangerStream changer = new DoctypeChangerStream(fileIn);
		changer.setGenerator(
				new DoctypeGenerator() {
				public Doctype generate(Doctype old) {
				if (old.getPublicId().equals("-//OASIS//DTD DocBook XML V4.1//EN")) {
				return new DoctypeImpl(
					old.getRootElement(),
					old.getPublicId(),
					"/usr/share/sgml/docbook/xml-dtd-4.1.2/docbookx.dtd",
					null
					);
				} else return null;
				}
				}
				);

		return changer;
	}

	public static void main(String args[]) throws Exception {
		if (args.length != 1) {
			System.err.println("Usage: java "+Parse.class.getName()+" &lt;valid XML file&gt;");
			return;
		}

		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		dbf.setNamespaceAware(true); // always do this. See http://xml.apache.org/~edwingo/jaxp-faq.html
		dbf.setValidating(true);
		DocumentBuilder db = dbf.newDocumentBuilder();
		Document doc = db.parse( getXMLStream(args[0]) );
		DocumentType doctype = doc.getDoctype();
		if (doctype != null) {
			System.out.println("Doctype:");
			System.out.println("\tName: "+doctype.getName());
			System.out.println("\tPublic Id: "+doctype.getPublicId());
			System.out.println("\tSystem Id: "+doctype.getSystemId());
			System.out.println("\tInternal Subset: "+doctype.getInternalSubset());
		}

	}
}
</pre>
<h2><a name="doc.Charset">Encoding issues</a></h2>

<p>
DoctypeChanger works by parsing the first part of the stream, byte by byte. One byte is
assumed to encode one character, and the encoding is assumed to be
ASCII-compatible. This is <em>not</em> true for multi-byte encodings,
specifically UTF-16 and UCS-4. So please don't use DoctypeChanger where you suspect
multi-byte encoding may be used.
</p>
<p>
This can't be "fixed" either, since the XML may have come with a MIME type
specifying the encoding. In this case, the MIME type charset parameter takes
preference over anything in the XML. Since DoctypeChanger has no access to this info,
we can never reliably figure out the encoding.
</p>
<p>
And if you didn't understand a word of the above, you probably don't have to
worry. 95% of XML out there is plain old UTF-8 or ISO-8859-1, and will work
fine with DoctypeChanger. If you want to impress your friends with your knowledge of
Unicode encoding, read <a
	href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">UTF-8 and Unicode FAQ
	for Unix/Linux</a>. It's 

</p>


<p>
</p>

<h2><a name="doc.CharVSByte"><code>FilterInputStream</code> vs <code>FilterReader</code></a></h2>

<p>
The <a href="http://www.simonstl.com/projects/doctypes/">original code</a>
implemented a filter for both byte streams and character streams. I have
limited myself to byte streams. If anyone wants to port this to char streams,
it should be very easy (literally a few lines), but porting the unit tests won't
be as fun. Here is some justification for byte streams, culled from the
original source:
</p>

<pre>
	/* Comments from Nigel Whitaker regarding using 
	a Stream rather than a Reader:

	My main comment is that I think extending a FilterInputStream would be
	a better choice than a FilterReader.  Let me try and explain my (and
	xml-dev's) reasoning/research:

	I am trying to use DoctypeChanger as a direct filter on the input to
	SAX (well SAX2 as in Xerces' XMLReader).  My original code created an
	org.xml.sax.InputSource and fed this into the parse method.  I then
	tried to add your Filter and started getting validation exceptions,
	even though I ensured your code was correctly adding a Doctype.

	The problem arises from the use of a Reader in this chain:

	java.io.File -> java.io.FileInputStream -> 
	java.io.InputStreamReader -> DoctypeChanger -> 
	org.xml.sax.InputSource -> parser.parse()

	My original working/validating code (with the Doctype added by hand) was:

	java.io.File -> java.io.FileInputStream -> 
	org.xml.sax.InputSource -> parser.parse()


	Although the use of Readers and Writers is the prefered way of
	doing Java IO since Java 1.1, it causes some problems with SAX parsing.
	It seems that SAX prefers to handle InputStreams of raw bytes
	because otherwise (with java.lang.Character based Readers) it cannot
	properly handle the encoding conversion issues of the input file.

	I did a bit of research and found that this issue was previously
	covered in a July 1999 xml-dev discussion entitled "encoding problem
	fixed".  It appears that depending on the platform-specific JVM
	Readers may default to different encodings.  See this thread:

	<a href="http://lists.xml.org/archives/xml-dev/199907/msg00413.html">http://lists.xml.org/archives/xml-dev/199907/msg00413.html</a>

	David Megginson also issued an "Important SAX Guideline" in this
	message:

	<a href="http://lists.xml.org/archives/xml-dev/199907/msg00414.html">http://lists.xml.org/archives/xml-dev/199907/msg00414.html</a>

	Always use an InputStream in preference to a Reader when you don't
	know the XML document's character encoding in advance.

	Users who use DoctypeChanger to write a temporary or intermediate file
	may not encounter this problem, only those who apply the Filter as
	part of the parsing, as I was doing.

	Following the guideline seems to have solved my problems.  The
	conversion to a FilterInputStream was a fairly simple change to your
	code. 
	*/
</pre>
<h2><a name="doc.Other">Other useful stuff</a></h2>

<p>
The following section has little to do with DoctypeChanger, but falls in the same
problem domain. If you're using DoctypeChanger, it's probably because you want to parse
XML from dubious sources. In this situation, there's a few other tips and code
snippets you may find useful. 
</p>

<h3><a name="doc.Validating">Validating against a local DTD</a></h3>

<p>
The best way to validate against a local DTD in Java is to retrieve the DTD
as a <em>resource</em>. A <em>resource</em> is anything loaded through the Java
classloader mechanism, with methods like
<code>Class.getResourceAsStream</code>. This is more portable than using
<code>java.io.File</code> as a data source, because you can retrieve your DTD
from inside a jar, inside unpackaged webapps, etc.
</p>

<p>The way to make parser retrieve the DTD from a resource is to implement a
<code>org.xml.sax.EntityResolver</code>. The parser will then call the
<code>resolveEntity</code> method when it wishes to retrieve the DTD, and this
is where you can return a DTD loaded as a resource.</p>

<p>Here is an <code>EntityResolver</code> class which, when it gets a request
for an entity with a specific public ID, will return bytes from a specific
resource.</p>
<pre>
import java.io.IOException;
import java.io.InputStream;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

/**
 * This SAX EntityResolver allows us to validate against local DTDs.
 * <code>
 * public static final String DSML_DTD_PUBLIC_ID = "http://www.dsml.org/DSML";
 * public static final String DSML_DTD_RESOURCE = "/net/socialchange/bob/dtds/dsml.dtd";
 * ..
 * ..
 * builder.setEntityResolver(new LocalEntityResolver(DSML_DTD_PUBLIC_ID, DSML_DTD_RESOURCE));
 * ..
 * SAXBuilder builder = new SAXBuilder(true);
 * </code>
 *
 * Stolen from jakarta tomcat 3.2.2, share/org/apache/jasper/compiler/JspUtil.java
 */
public class LocalEntityResolver implements EntityResolver {

    String dtdId;
    String dtdResource;

    public LocalEntityResolver(String id, String resource) {
        this.dtdId = id;
        this.dtdResource = resource;
    }

    public InputSource resolveEntity(String publicId, String systemId)
        throws SAXException, IOException
        {
            //System.out.println ("publicId = " + publicId);
            //System.out.println ("systemId is " + systemId);
            //System.out.println ("resource is " + dtdResource);
            if (publicId == null) {return null; }
            if (publicId.equals(dtdId)) {
                InputStream input =
                    this.getClass().getResourceAsStream(dtdResource);
                InputSource isrc =
                    new InputSource(input);
                return isrc;
            }
            else {
                //System.out.println ("returning null");
                return null;
            }
        }
}
</pre>

<p>
This can be used in conjunction with DoctypeChanger. You would typically configure
DoctypeChanger to change the public id to a preset value. Then configure
<code>LocalEntityResolver</code> to return a DTD for that preset value, and
you're set. All incoming XML will be validated against your local DTD.
</p>

<h3><a name="doc.Catalogs">XML Catalogs</a></h3>
<p>
Entity catalogs are wonderful things from SGML land, which are still relatively
rare in XML applications. If you're not familiar with them, read <a
	href="http://www.arbortext.com/Think_Tank/XML_Resources/Issue_Three/issue_three.html">Norm
	Walsh's article</a>, which also introduces some code for catalog-based
entity resolution. You should see some parallels with what DoctypeChanger tries to
achieve. Like DoctypeChanger, catalogs allow you to remap from one DOCTYPE declaration
to another.
</p>
<p>
Despite some overlap, two tools (DoctypeChanger and catalog resolution code) are
really aimed at solving different problems. DoctypeChanger is more flexible in what it
can do to DOCTYPE declarations, but it is for once-off parsing jobs, not a
generalized entity resolution system like catalogs.
</p>
<h4>Where to get catalog code</h4>
<p>
Currently (April 15 2002), you can download the public domain Arbortext catalog
software mentioned in the article, <a
	href="http://www.arbortext.com/Customer_Support/Updates_and_Technical_Notes/java_form.html">here</a>,
or you can download the much-enhanced Sun code from <a
	href="http://www.sun.com/xml/developers/resolver/">http://www.sun.com/xml/developers/resolver/</a>.
</p>

<h2><a name="doc.Feedback">Feedback</a></h2>
<p>
Any comments, bug reports, enhancements and the like welcome. Email Jeff Turner at <a href="mailto:jeff@socialchange.net.au">jeff@socialchange.net.au</a>.
</p>

<h2><a name="doc.ChangeLog">ChangeLog</a></h2>
<p>
<dl>
	<dt>Version 1.1</dt>
	<dd>Bugfix release: fixes a bug where commented-out doctype declarations
	were being modified. Eg., if we had:
	<code>
		<?xml version="1.0"?>
		<!-- <!DOCTYPE foo SYSTEM "http://example.com/foo-old.dtd"> -->
		<!DOCTYPE newFoo SYSTEM "http://example.com/foo.dtd">
		<newFoo/>
	</code>
	Then the commented-out doctype would be used/modified instead of the
	correct one.
	<p>Thanks to José María Fernández González for reporting this.</p>
	<p>Also changed from Mozilla license to a less restrictive/complex Apache
	derivative (consent obtained from the original author).</p>
	</dd>
	<dt>Version 1.05</dt>
	<dd>First public release (XML-DEV, general@jakarta, general@xml)</dd>
</dl>
</p>


<h2><a name="doc.License">License, copyright, legal stuff</a></h2>
<p>Copyright (c) 1999-2001 by Simon St.Laurent and Jeff Turner.  All Rights
Reserved.</p>
<p>
	This code is licensed under a modified <a
		href="http://www.apache.org/LICENSE.txt">Apache Software License
		1.1</a> without the advertising clause.
</p>
<p>
And the usual disclaimer..
</p>
<p>This program is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the LICENSE.txt for
more details.
</p>
<P>
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="net/socialchange/doctype/package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
Copyright © 2001 Social Change Online. All Rights Reserved.
</BODY>
</HTML>
